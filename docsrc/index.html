<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- $Id: index.html,v 1.46 2003/06/15 11:53:19 obecker Exp $ -->
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
      <title>Joost</title>
      <style type="text/css">
        body { font-family: sans-serif; background-color: #eeeeff; }
        h1 { color: yellow; background-color: #000066; text-align: center;
             padding: 4pt;}
        h3 { text-align: center; }
        h4 { color: white; background-color: #006; padding: 3pt; }
      </style>
   </head>
   <body link="#993333" vlink="#663333">
      <h1>Joost</h1>
      <h3>is Oli's Original Streaming Transformer</h3>

      <p>
      This page contains information about the world's first prototypic
      Java implementation of the
      <strong><a target="_top"
      href="http://stx.sourceforge.net">Streaming Transformations
      for XML (STX)</a>.</strong>
      It is intended as a kind of reference implementation which
      demonstrates the functionality of STX.<br>
      (And by the way: Joost [pronounced <em>yohst</em>] is also the
      given name of a good friend's little son ...)
      </p>

      <table cellspacing="10pt" width="40%" align="right"
             style="background-color: #ffffee;
                    margin-left: 10pt; margin-bottom: 10pt">
      <tr><td>
        <p><strong>Tell me about your use cases</strong></p>
        <p>I'm currently writing an academic thesis about different
        transformation approaches. So I am particularly interested in
        your use case for STX:</p>
        <ul>
          <li>How would you characterize your data?</li>
          <li>Have you used XSLT before?
              Do you see advantages over XSLT in using STX?</li>
          <li>Have you used any other transformation approach on your data
              before switching to STX? Which one?</li>
        </ul>
        <p>In case you've tried STX/Joost but haven't found any improvements
        for your application, I'm also interested in what you've expected
        and why STX/Joost failed.</p>
        <p>Of course I don't want any confidential data. I'm only interested
        in the nature of your use case.</p>
        <p>Please send me a
        <a href="mailto:obecker@informatik.hu-berlin.de">personal e-mail</a>
        if you want to share your experience with me. The academic world and
        me will always appreciate your support. :-)</p>
      </td></tr>
      </table>

      <p>The latest version was created <strong>@@@DATE@@@</strong>
      and may be <strong><a target="_top"
         href="https://sourceforge.net/project/showfiles.php?group_id=55258">
      downloaded here</a></strong>. Note: it should still be regarded
      as an alpha version.</p>
      <p>
      <em>Joost</em> is released under the Mozilla Public License 1.1.
      Have a look at the
      <a target="_top"
         href="https://sourceforge.net/projects/joost">project page</a>
      for more information. Any questions concerning <em>Joost</em> may be
      asked on the
      <a target="_top"
         href="http://lists.sourceforge.net/lists/listinfo/joost-help">joost-help</a>
      mailing list.
      </p>
      <p>
      For running <em>Joost</em> you need additionally
      <ul>
         <li>
            a SAX2 Parser, for example Crimson (already included in
            Java 1.4 or downloadable separately on
            <a target="_top"
               href="http://java.sun.com/xml/downloads/javaxmlpack.html">Sun's
            Java XML Pack page</a>),
            <a target="_top"
               href="http://xml.apache.org/xerces2-j/">Xerces</a>
            from Apache XML, or Ælfred2 from the
            <a target="_top"
               href="http://www.gnu.org/software/classpathx/jaxp/">GNU JAXP
            Project</a>
         </li>
         <li>
            the JAXP 1.1 interfaces (also included in Java 1.4 or
            downloadable from the Sun link above)
         </li>
         <li>
            the <a target="_top"
            href="http://jakarta.apache.org/commons/logging.html">Logging
            Component</a> from Apache Jakarta Commons</li>
         <li>and of course a Java platform, at least version 1.2</li>
      </ul>
      <p>
      Run <em>Joost</em> with
      <strong><code>java net.sf.joost.Main xml-source stx-sheet</code></strong>
      <br>
      or simply
      <strong><code>java -jar joost.jar xml-source stx-sheet</code></strong>
      </p>
      <p>Global parameters for the STX transformation sheet may be specified
      by adding command line arguments of the form
      <strong><code>parameter=value</code></strong>. <code>value</code>
      is interpreted as a string, not as an expression.</p>
      <p>
      To get a list of possible options use the command line parameter
      <strong><code>-help</code></strong>
      </p>
      <p><em>Joost</em> is able to pass its output to <a target="_top"
      href="http://xml.apache.org/fop/">FOP</a> for producing PDF output
      from a stream of XSLFO SAX events. To use this functionality you
      have to add fop.jar, batik.jar and avalon.jar (FOP 0.20.4 comes
      with avalon-framework-cvs-20020315.jar) to your classpath.
      There's no possibility to change FOP's verbosity on the command
      line at the moment (<em>Joost</em> sets it to <code>warn</code>).
      </p>

      <p><em>Joost</em> implements the TrAX interfaces from JAXP 1.1.
      For creating a <em>Joost</em> transformer you have to set the Java
      property <code>javax.xml.transform.TransformerFactory</code>
      to the value <code>net.sf.joost.trax.TransformerFactoryImpl</code>.
      </p>
      
      <h4>Features</h4>
      <p>
      <strong>Supported stx elements</strong> (and their attributes)
      in the namespace <code>http://stx.sourceforge.net/2002/ns</code>
      <ul>
      <li>stx:transform (version, stxpath-default-namespace?,
          output-encoding?, pass-through?, strip-space?,
          recognize-cdata?, exclude-result-prefixes?)</li>
      <li>stx:group (name?, pass-through?, strip-space?,
          recognize-cdata?)</li>
      <li>stx:include (href)</li>
      <li>stx:template (match, priority?, public?, visibility?,
                        new-scope?)</li>
      <li>stx:procedure (name, public?, visibility?, new-scope?)</li>
      <li>stx:call-procedure (name, group?)</li>
      <li>stx:copy (attributes?)</li>
      <li>stx:process-children (group?, filter?, src?)</li>
      <li>stx:process-self (group?, filter?, src?)</li>
      <li>stx:process-siblings (group?, while?, until?)</li>
      <li>stx:process-attributes (group?)</li>
      <li>stx:process-document (href, base?, group?)</li>
      <li>stx:result-document (href, encoding?)</li>
      <li>stx:buffer (name)</li>
      <li>stx:result-buffer (name, clear?)</li>
      <li>stx:process-buffer (name, group?, filter?, src?)</li>
      <li>stx:value-of (select, separator?)</li>
      <li>stx:if (test)</li>
      <li>stx:else</li>
      <li>stx:choose</li>
      <li>stx:when (test)</li>
      <li>stx:otherwise</li>
      <li>stx:for-each-item (name, select)</li>
      <li>stx:while (test)</li>
      <li>stx:text</li>
      <li>stx:cdata</li>
      <li>stx:element (name, namespace?)</li>
      <li>stx:start-element ({name}, {namespace}?)</li>
      <li>stx:end-element ({name}, {namespace}?)</li>
      <li>stx:attribute ({name}, {namespace}?, select)</li>
      <li>stx:comment</li>
      <li>stx:processing-instruction ({name})</li>
      <li>stx:variable (name, select?, keep-value?)</li>
      <li>stx:assign (name, select)</li>
      <li>stx:param (name, select?, required?)</li>
      <li>stx:with-param (name, select?)</li>
      <li>stx:message &ndash;
          (<em>prints its content to standard error output</em>)</li>
      </ul>
      <p>
      <strong>Supported STXPath functions</strong>
      <ul>
      <li>string(obj?)</li>
      <li>number(obj?)</li>
      <li>boolean(obj)</li>
      <li>position()</li>
      <li>name(node?)</li>
      <li>local-name(node?)</li>
      <li>namespace-uri(node?)</li>
      <li>prefix(node?)</li>
      <li>get-namespace-uri-for-prefix(node, string)</li>
      <li>get-in-scope-namespaces(node)</li>
      <li>node-kind(node)</li>
      <li>not(boolean)</li>
      <li>true()</li>
      <li>false()</li>
      <li>floor(number)</li>
      <li>ceiling(number)</li>
      <li>round(number)</li>
      <li>concat(string, string+)</li>
      <li>string-length(string?)</li>
      <li>normalize-space(string?)</li>
      <li>contains(string, string)</li>
      <li>starts-with(string, string)</li>
      <li>substring(string, string, string?)</li>
      <li>substring-before(string, string)</li>
      <li>substring-after(string, string)</li>
      <li>translate(string, string, string)</li>
      <li>has-child-nodes()</li>
      <li>empty(sequence)</li>
      <li>item-at(sequence, number)</li>
      <li>subsequence(sequence, number, number?)</li>
      <li>count(sequence)</li>
      <li>sum(sequence)</li>
      <li>filter-available(string)</li>
      </ul>
      <p>
      <strong>Built-in extension functions</strong><br>
      A built-in extension function must be used with a fully-qualified
      name and the prefix bound to the namespace
      <code>http://joost.sf.net/functions</code>
      <ul>
      <li>sequence(obj)<br>
          converts a Java array or a <code>java.util.List</code> object to
          a sequence, see <em>Extensions</em> below</li>
      </ul> 

      <h4>Limitations</h4>
      <ul>
         <li>no full Unicode support
             (allow currently only ASCII characters in names,
             pay no attention to surrogate pairs)</li>
         <li>TrAX: URIResolver not supported</li>
         <li>all STX elements and functions not explicitely mentioned
             on this page wait for an implementation</li>
         <li>...</li>
      </ul>

      <h4>Extensions</h4>
      <p>
      <em>Joost</em> allows calling extension functions written in Java. An
      extension function is invoked using the notation
      <code>prefix:localname(<em>params?</em>)</code>. The
      <code>prefix</code> must be bound to a namespace indicating the Java
      class the function belongs to. This namespace must use the URN
      notation "<code>java:</code>" followed by the full-qualified class name,
      for example "<code>java:java.util.Random</code>". The referenced class
      must be found in the current classpath.
      </p>
      <p>
      The rules for calling Java extension functions are similar to those
      used by Saxon or Xalan:
      </p>
      <ul>
        <li>
          <p>
            A <strong>static method</strong> can be called directly.
            The localname of the function must match the name of a public
            static method in this class. The names match if they contain
            the same characters, excluding hyphens and forcing any character
            that follows a hyphen to upper-case. For example the STXPath
            function call <code>prefix:to-string()</code> matches the Java
            method <code>toString();</code> but the function call can also
            be written as <code>prefix:toString()</code> if you prefer.
          </p>
          <p>
            The number of the arguments supplied to the function call must
            match exactly the number of the parameters of the Java method.
            If there are more than one candidate, <em>Joost</em> attempts
            to find the one that is the best fit to the types of the
            supplied arguments (see <em>Conversion rules</em> below).
            <em>Joost</em> will report an error if no matching method at
            all can be found, or if several methods may be used but none
            is preferable to the others.
          </p>
          <p>
            Example:
            <br> 
            <code>&lt;stx:value-of select="math:sqrt($arg)"
                  xmlns:math="java:java.lang.Math"/&gt;</code>
          </p>
        </li>
        <li>
          <p>
            A <strong>constructor</strong> is called by using a function
            named <code>prefix:new</code>. If there are several constructors,
            then again <em>Joost</em> tries to find the one that is the best
            fit, according to the types of the supplied arguments. The result
            of calling <code>new()</code> is an STXPath value of type Java
            Object; the only things that can be done with a Java Object are
            to assign it to a variable, to pass it to an extension function,
            and to convert it to a <code>string</code>, <code>number</code>,
            or <code>boolean</code>, using the rules given below.
          </p>
        </li>
        <li>
          <p>
            An <strong>instance-level method</strong> is called by supplying
            an extra first argument of type Java Object which is the object
            on which the method is to be invoked. Matching of method names
            is done as for static methods.
          </p>
          <p>
            Example: <br>
            <code>&lt;stx:value-of select="date:to-string(date:new())"
                  xmlns:date="java:java.util.Date" /&gt;</code>
          </p>
        </li>
      </ul>
      <p><strong>Conversion rules</strong><br>
      Depending on the type of the values supplied to the function call,
      <em>Joost</em> tries to find a method that has an argument with one
      of the following types (Java types with a higher conversion preference
      appear first in the list; if the argument in the function call is a
      non-empty sequence, only the first item will be considered):
      </p>
      <table border="1" cellpadding="4" cellspacing="0">
        <tr>
          <th>supplied STXPath type</th>
          <th>required Java type</th>
        </tr>
        <tr>
          <td>empty sequence</td>
          <td><code>java.util.List</code>, <code>java.lang.Object</code>
              (or a derived type, i.e. a reference type)</td>
        </tr>
        <tr>
          <td><code>boolean</code></td>
          <td><code>boolean</code>, <code>byte</code>, <code>short</code>,
              <code>int</code>, <code>long</code>, <code>char</code>,
              <code>java.lang.String</code>, <code>float</code>,
              <code>double</code>, <code>java.util.List</code>,
              <code>java.lang.Object</code></td>
        </tr>
        <tr>
          <td><code>number</code></td>
          <td><code>double</code>, <code>float</code>, <code>long</code>,
              <code>int</code>, <code>short</code>, <code>byte</code>,
              <code>java.lang.String</code>, <code>char</code>,
              <code>boolean</code>, <code>java.util.List</code>,
              <code>java.lang.Object</code></td>
        </tr>
        <tr>
          <td><code>node</code>, <code>string</code></td>
          <td><code>java.lang.String</code>, <code>char</code>,
              <code>double</code>, <code>float</code>, <code>int</code>,
              <code>long</code>, <code>short</code>, <code>byte</code>,
              <code>boolean</code>, <code>java.util.List</code>,
              <code>java.lang.Object</code></td>
        </tr>
        <tr>
          <td>wrapped Java Object</td>
          <td>same type, base type, <code>java.lang.Object</code>,
              <code>java.util.List</code>, <code>java.lang.String</code></td>
        </tr>
      </table>
      <p>
      If the target type is <code>java.lang.Object</code> then a conversion
      according to the following table will be performed. If the target type
      is <code>java.util.List</code> then a <code>java.util.ArrayList</code>
      will be constructed containing a list of <code>java.lang.Object</code>s
      (see table) for each of the items. An empty sequence will be
      represented as an empty list (not as a list with a <code>null</code>
      member).
      </p>
      <table border="1" cellpadding="4" cellspacing="0">
        <tr>
          <th>supplied STXPath type</th>
          <th>target type <code>java.lang.Object</code></th>
        </tr>
        <tr>
          <td>empty sequence</td>
          <td><code>null</code></td>
        </tr>
        <tr>
          <td><code>boolean</code></td>
          <td><code>java.lang.Boolean</code> containing the boolean value</td>
        </tr>
        <tr>
          <td><code>number</code></td>
          <td><code>java.lang.Double</code> containing the number</td>
        </tr>
        <tr>
          <td><code>string</code></td>
          <td><code>java.lang.String</code></td>
        </tr>
        <tr>
          <td><code>node</code></td>
          <td><code>java.lang.String</code> containing the node value</td>
        </tr>
        <tr>
          <td>wrapped Java Object</td>
          <td>the object itself</td>
        </tr>
      </table>
              
                
      <p>
      The result of a function call will be converted as follows:
      </p>
      <table border="1" cellpadding="4" cellspacing="0">
        <tr>
          <th>return type</th>
          <th>STXPath type / value</th>
        </tr>
        <tr>
          <td><code>void</code></td>
          <td>empty sequence</td>
        </tr>
        <tr>
          <td><code>java.lang.String</code>, <code>char</code></td>
          <td><code>string</code></td>
        </tr>
        <tr>
          <td><code>boolean</code></td>
          <td><code>boolean</code></td>
        </tr>
        <tr>
          <td><code>double</code>, <code>float</code>, <code>byte</code>,
              <code>short</code>, <code>int</code>, <code>long</code></td>
          <td><code>number</code></td>
        </tr>
        <tr>
          <td>anything else, i.e. any reference type, including the value
              <code>null</code></td>
          <td>wrapped Java Object</td>
        </tr>
      </table>
      <p>A wrapped Java Object may be converted to another data type as
      follows.</p>
      <table border="1" cellpadding="4" cellspacing="0">
        <tr>
          <th>required type</th>
          <th>conversion rule</th>
        </tr>
        <tr>
          <td><code>node</code></td>
          <td>not possible</td>
        </tr>
        <tr>
          <td><code>string</code></td>
          <td><code>null</code> will be converted to the empty string,
              any other object will be converted by calling its
              <code>toString()</code> method</td>
        </tr>
        <tr>
          <td><code>boolean</code></td>
          <td><code>null</code> will be converted to <code>false</code>,
              any other object will be converted via a
              <code>string</code> conversion and then applying the
              STXPath function <code>boolean()</code></td>
        </tr>
        <tr>
          <td><code>number</code></td>
          <td>via a <code>string</code> conversion and then applying the
              STXPath function <code>number()</code></td>
        </tr>
      </table>

      <p>
        A wrapped Java Object of type <code>java.lang.Object[]</code> or
        <code>java.util.List</code> may be converted to a sequence using
        the <em>Joost</em> extension function <code>sequence</code>.
        If the supplied parameter is neither an array nor a
        <code>java.util.List</code> object, this function returns its
        parameter.
      </p>

        
      <h4>Examples</h4>
      <p>
      The current release contains an <code>example</code> directory with a
      set of selected STX examples. Additionally you may browse
      <em>Joost</em>'s CVS <a target="_top"
      href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/joost/test/">test</a>
      directory as well as the <a target="_top"
      href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/stx/stx/examples/">examples</a> directory from the STX CVS tree.

      <p>
      <a target="_top" href="http://sourceforge.net">
      <img src="http://sourceforge.net/sflogo.php?group_id=55258&amp;type=5"
           width="210" height="62" border="0" alt="SourceForge Logo"
           align="right" style="margin-bottom: 5pt;"></a>
      <strong>Have fun and tell me what you think!</strong><br>
      <div style="font-size: small">
         <a target="_top"
            href="http://www.informatik.hu-berlin.de/~obecker/index_e.shtml">ob</a> / @@@DATE@@@
      </div>
   </body>
</html>
