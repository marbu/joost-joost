<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- $Id: index.html,v 1.67 2004/08/23 19:41:03 obecker Exp $ -->
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
      <title>Joost</title>
      <style type="text/css">
        body { font-family: sans-serif; background-color: #eeeeff; }
        h1 { color: yellow; background-color: #000066; text-align: center;
             padding: 4pt;}
        h3 { text-align: center; }
        h4 { color: white; background-color: #006; padding: 3pt; }
      </style>
   </head>
   <body link="#993333" vlink="#663333">
      <h1>Joost</h1>
      <h3>is Oli's Original Streaming Transformer</h3>

      <hr size="1" noshade>
      <blockquote>
        <strong>News:</strong><br>
        2004-05-10:
        <strong>
          <a href="http://www.informatik.hu-berlin.de/~zubow/stdb/">
            StDB 0.1 released
          </a>
        </strong><br>
        StDB is a debugger for STX, based on Joost
      </blockquote>
      <hr size="1" noshade>
    
      <p>
      This page contains information about the world's first prototypic
      Java implementation of the
      <strong><a target="_top"
      href="http://stx.sourceforge.net">Streaming Transformations
      for XML (STX)</a></strong> language.
      It is intended as a reference implementation which
      demonstrates the functionality of STX.<br>
      (And by the way: Joost [pronounced <em>yohst</em>] is also the
      given name of a good friend's little son ...)
      </p>

      <p>The latest version was created <strong>@@@DATE@@@</strong>
      and may be <strong><a target="_top"
         href="https://sourceforge.net/project/showfiles.php?group_id=55258">
      downloaded here</a></strong>. Note: though the code runs hopefully
      without major crashes, it should still be regarded as an alpha
      version.</p>
      <p>
      <em>Joost</em> is released under the Mozilla Public License 1.1.
      Have a look at the
      <a target="_top"
         href="https://sourceforge.net/projects/joost">project page</a>
      for further information. Any questions concerning <em>Joost</em> may be
      asked on the
      <a target="_top"
         href="http://lists.sourceforge.net/lists/listinfo/joost-help">joost-help</a>
      mailing list.
      </p>
      <p>
      In order to run <em>Joost</em> you need additionally
      <ul>
         <li>
            a SAX2 Parser, for example Crimson (already included in
            Java 1.4 or downloadable separately on
            <a target="_top"
               href="http://java.sun.com/xml/downloads/javaxmlpack.html">Sun's
            Java XML Pack page</a>),
            <a target="_top"
               href="http://xml.apache.org/xerces2-j/">Xerces</a>
            from Apache XML, or Ælfred2 from the
            <a target="_top"
               href="http://www.gnu.org/software/classpathx/jaxp/">GNU JAXP
            Project</a>
         </li>
         <li>
            the JAXP 1.1 interfaces (also included in Java 1.4 or
            downloadable from the Sun link above)
         </li>
         <li>
            the <a target="_top"
            href="http://jakarta.apache.org/commons/logging.html">Logging
            Component</a> from Apache Jakarta Commons</li>
         <li>and of course a Java platform, at least version 1.2</li>
      </ul>
      <p>
      Run <em>Joost</em> with<br>
      <strong><code>java net.sf.joost.Main [opts] <em>xml-source stx-sheet</em>
      [pars] {<em>stx-sheet</em> [pars]}</code></strong>
      <br>
      or simply<br>
      <strong><code>java -jar joost.jar [opts] <em>xml-source stx-sheet</em>
      [pars] {<em>stx-sheet</em> [pars]}</code></strong>
      </p>
      <p>The dash character "<code>-</code>" for the <code>xml-source</code>
      parameter denotes the standard input. The specification of multiple
       <code>stx-sheet</code>s creates a transformation chain.
      Global parameters for each STX transformation sheet may be specified
      by adding command line arguments (<code>pars</code>) of the form
      <strong><code>parameter=value</code></strong> directly after
      each <code>stx-sheet</code>. <code>value</code>
      is interpreted as a string, not as an expression.</p>
      <p>The list of possible options includes</p>
      <table>
        <tr>
          <td rowspan="6">&nbsp;&nbsp;&nbsp;</td>
          <td valign="top"><strong><code>-help</code></strong></td>
          <td rowspan="6">&nbsp;</td>
          <td>print a help message</td>
        </tr>
        <tr>
          <td valign="top"><strong><code>-version</code></strong></td>
          <td>print the version information and exit</td>
        </tr>
        <tr>
          <td valign="top"><strong><code>-o &lt;filename&gt;</code></strong></td>
          <td>write the result to the file &lt;filename&gt;</td>
        </tr>
        <tr>
          <td valign="top"><strong><code>-m &lt;classname&gt;</code></strong></td>
          <td>use a &lt;classname&gt; object for stx:message output<br>
              this class must implement the interface
              net.sf.joost.emitter.StxEmitter</td>
        </tr>
        <tr>
          <td valign="top"><strong><code>-time</code></strong></td>
          <td>print timing information on standard error output</td>
        </tr>
        <tr>
          <td valign="top"><strong><code>-pdf</code></strong></td>
          <td>pass the result to FOP for PDF generation (requires -o),
              see below</td>
        </tr>
      </table>

      <p><em>Joost</em> is able to pass its output to <a target="_top"
      href="http://xml.apache.org/fop/">FOP</a> for producing PDF output
      from a stream of XSLFO SAX events. To use this function you
      have to add fop.jar, batik.jar and avalon.jar (FOP 0.20.5 comes
      with avalon-framework-cvs-20020806.jar) to your classpath.
      It is not possible to change FOP's verbosity on the command
      line at the moment (<em>Joost</em> sets it to <code>warn</code>).
      </p>

      <p><em>Joost</em> implements the TrAX interfaces from JAXP 1.1.
      In order to create a <em>Joost</em> transformer you have to set the Java
      property <code>javax.xml.transform.TransformerFactory</code>
      to the value <code>net.sf.joost.trax.TransformerFactoryImpl</code>.
      </p>
      
      <h4>Features</h4>
      <p>
      <strong>Supported stx elements</strong> (and their attributes)
      in the namespace <code>http://stx.sourceforge.net/2002/ns</code>
      <ul>
      <li>stx:transform (version, stxpath-default-namespace?,
          output-method?, output-encoding?, pass-through?, strip-space?,
          recognize-cdata?, exclude-result-prefixes?)</li>
      <li>stx:group (name?, pass-through?, strip-space?,
          recognize-cdata?)</li>
      <li>stx:include (href)</li>
      <li>stx:namespace-alias (stylesheet-prefix, result-prefix) &ndash;
          (<em>uses the stylesheet-prefix in the result</em>)</li>
      <li>stx:template (match, priority?, public?, visibility?,
                        new-scope?)</li>
      <li>stx:procedure (name, public?, visibility?, new-scope?)</li>
      <li>stx:call-procedure (name, group?)</li>
      <li>stx:copy (attributes?)</li>
      <li>stx:process-children (group?, filter-method?, filter-src?)</li>
      <li>stx:process-self (group?, filter-method?, filter-src?)</li>
      <li>stx:process-siblings (group?, while?, until?)</li>
      <li>stx:process-attributes (group?)</li>
      <li>stx:process-document (href, base?, group?,
                                filter-method?, filter-src?)</li>
      <li>stx:result-document (href, output-method?, output-encoding?)</li>
      <li>stx:buffer (name)</li>
      <li>stx:result-buffer (name, clear?)</li>
      <li>stx:process-buffer (name, group?, filter-method?, filter-src?)</li>
      <li>stx:value-of (select, separator?)</li>
      <li>stx:if (test)</li>
      <li>stx:else</li>
      <li>stx:choose</li>
      <li>stx:when (test)</li>
      <li>stx:otherwise</li>
      <li>stx:for-each-item (name, select)</li>
      <li>stx:while (test)</li>
      <li>stx:text</li>
      <li>stx:cdata</li>
      <li>stx:element (name, namespace?)</li>
      <li>stx:start-element ({name}, {namespace}?)</li>
      <li>stx:end-element ({name}, {namespace}?)</li>
      <li>stx:attribute ({name}, {namespace}?, select)</li>
      <li>stx:comment</li>
      <li>stx:processing-instruction ({name})</li>
      <li>stx:variable (name, select?, keep-value?)</li>
      <li>stx:assign (name, select)</li>
      <li>stx:param (name, select?, required?)</li>
      <li>stx:with-param (name, select?)</li>
      <li>stx:message (select?) &ndash;
          (<em>prints its content to standard error output</em>)</li>
      </ul>
      <p>
      <strong>Supported STXPath functions</strong>
      <ul>
      <li>string(object?)</li>
      <li>number(object?)</li>
      <li>boolean(object)</li>
      <li>position()</li>
      <li>name(node?)</li>
      <li>local-name(node?)</li>
      <li>namespace-uri(node?)</li>
      <li>get-namespace-uri-for-prefix(string, node)</li>
      <li>get-in-scope-prefixes(node)</li>
      <li>node-kind(node)</li>
      <li>not(boolean)</li>
      <li>true()</li>
      <li>false()</li>
      <li>floor(number)</li>
      <li>ceiling(number)</li>
      <li>round(number)</li>
      <li>concat(string, string+)</li>
      <li>string-join(sequence, string)</li>
      <li>string-length(string?)</li>
      <li>normalize-space(string?)</li>
      <li>contains(string, string)</li>
      <li>starts-with(string, string)</li>
      <li>ends-with(string, string)</li>
      <li>substring(string, string, string?)</li>
      <li>substring-before(string, string)</li>
      <li>substring-after(string, string)</li>
      <li>translate(string, string, string)</li>
      <li>string-pad(string, number)</li>
      <li>escape-uri(string, boolean)</li>
      <li>has-child-nodes()</li>
      <li>empty(sequence)</li>
      <li>exists(sequence)</li>
      <li>item-at(sequence, number)</li>
      <li>index-of(sequence, object)</li>
      <li>subsequence(sequence, number, number?)</li>
      <li>insert-before(sequence, number, sequence)</li>
      <li>remove(sequence, number)</li>
      <li>count(sequence)</li>
      <li>sum(sequence)</li>
      <li>min(sequence)</li>
      <li>max(sequence)</li>
      <li>avg(sequence)</li>
      <li>filter-available(string)</li>
      </ul>
      <p>
      <strong>Built-in extension functions</strong><br>
      A built-in extension function must be used with a fully-qualified
      name and the prefix bound to the namespace
      <code>http://joost.sf.net/functions</code>
      <ul>
      <li>sequence(obj)<br>
          converts a Java array or a <code>java.util.List</code> object to
          a sequence, see <em>Extensions</em> below</li>
      </ul> 

      <h4>Limitations</h4>
      <ul>
         <li>no full Unicode support
             (allow currently only ASCII characters in names,
             pay no attention to surrogate pairs)</li>
         <li>all STX elements and functions not explicitely mentioned
             on this page wait for an implementation</li>
         <li>...</li>
      </ul>

      <h4>Extensions</h4>
      <p>
        <em>Joost</em> allows the use of extension functions written in Java.
        An extension function is invoked using the notation
        <code>prefix:localname(<em>params?</em>)</code>. The
        <code>prefix</code> must be bound to a namespace indicating the Java
        class to which the function belongs. This namespace must use the URN
        notation "<code>java:</code>" followed by the full-qualified class
        name, for example "<code>java:java.util.Random</code>". The
        referenced class must be found in the current classpath.
      </p>
      <p>
        The rules for invoking Java extension functions are similar to those
        used by Saxon or Xalan:
      </p>
      <ul>
        <li>
          <p>
            A <strong>static method</strong> can be invoked directly.
            The local name of the function must match the name of a public
            static method in this class. The names match if they contain
            the same characters, excluding hyphens and forcing any character
            that follows a hyphen to upper-case. For example the STXPath
            function call <code>prefix:to-string()</code> matches the Java
            method <code>toString();</code> but if you prefer, the function
            call can also be written as <code>prefix:toString()</code>.
          </p>
          <p>
            The number of the arguments supplied to the function call must
            match exactly the number of the parameters of the Java method.
            If there are more than one candidate, <em>Joost</em> attempts
            to find the one that is the best fit to the types of the
            supplied arguments (see <em>Conversion rules</em> below).
            <em>Joost</em> will report an error if no matching method at
            all can be found, or if several methods may be used but none
            is preferable to the others.
          </p>
          <p>
            Example:
            <br> 
            <code>&lt;stx:value-of select="math:sqrt($arg)"
                  xmlns:math="java:java.lang.Math"/&gt;</code>
          </p>
        </li>
        <li>
          <p>
            A <strong>constructor</strong> is invoked by using a function
            named <code>prefix:new</code>. If there are several constructors,
            then again <em>Joost</em> tries to find the one that is the best
            fit, according to the types of the supplied arguments. The result
            of invoking <code>new()</code> is an STXPath value of type Java
            Object; the only things that can be done with a Java Object are
            to assign it to a variable, to pass it to an extension function,
            and to convert it to a <code>string</code>, <code>number</code>,
            or <code>boolean</code>, using the rules given below.
          </p>
        </li>
        <li>
          <p>
            An <strong>instance-level method</strong> is invoked by supplying
            an extra first argument of type Java Object which is the object
            on which the method is to be invoked. Matching of method names
            is done as for static methods.
          </p>
          <p>
            Example: <br>
            <code>&lt;stx:value-of select="date:to-string(date:new())"
                  xmlns:date="java:java.util.Date" /&gt;</code>
          </p>
        </li>
      </ul>
      <p>
        It is recommended not to invoke an extension function having
        side-effects within the predicates of a match pattern, because
        the order of these function calls and whether such a function
        will be used at all is undefined (implementation dependent).<br>
        (For example in
        <code>match="a[ex:foo()]//b[ex:bar()]/c[ex:baz()]"</code>)
      </p>
      <p>
        <strong>Conversion rules</strong><br>
        Depending on the type of the argument values supplied to the function
        call, <em>Joost</em> tries to find a method that has parameters of
        the following types (Java types with a higher conversion preference
        appear first in the list; if one parameter is of a primitve type and
        the argument in the function call is a non-empty sequence, only the
        first item will be considered):
      </p>
      <table border="1" cellpadding="4" cellspacing="0">
        <tr>
          <th>supplied STXPath type</th>
          <th>required Java type</th>
        </tr>
        <tr>
          <td>empty sequence</td>
          <td><code>java.util.List</code>, <code>java.lang.Object</code>
              (or a derived type, i.e. a reference type)</td>
        </tr>
        <tr>
          <td><code>boolean</code></td>
          <td><code>boolean</code>, <code>byte</code>, <code>short</code>,
              <code>int</code>, <code>long</code>, <code>char</code>,
              <code>java.lang.String</code>, <code>float</code>,
              <code>double</code>, <code>java.util.List</code>,
              <code>java.lang.Object</code></td>
        </tr>
        <tr>
          <td><code>number</code></td>
          <td><code>double</code>, <code>float</code>, <code>long</code>,
              <code>int</code>, <code>short</code>, <code>byte</code>,
              <code>java.lang.String</code>, <code>char</code>,
              <code>boolean</code>, <code>java.util.List</code>,
              <code>java.lang.Object</code></td>
        </tr>
        <tr>
          <td><code>node</code>, <code>string</code></td>
          <td><code>java.lang.String</code>, <code>char</code>,
              <code>double</code>, <code>float</code>, <code>int</code>,
              <code>long</code>, <code>short</code>, <code>byte</code>,
              <code>boolean</code>, <code>java.util.List</code>,
              <code>java.lang.Object</code></td>
        </tr>
        <tr>
          <td>wrapped Java Object</td>
          <td>same type, base type, <code>java.lang.Object</code>,
              <code>java.util.List</code>, <code>java.lang.String</code></td>
        </tr>
      </table>
      <p>
        If the target type is <code>java.lang.Object</code> then a conversion
        according to the following table will be performed. If the target type
        is <code>java.util.List</code> then a <code>java.util.ArrayList</code>
        will be constructed containing a list of
        <code>java.lang.Object</code>s (see table) for each of the items. An
        empty sequence will be represented as an empty list (not as a list
        with a <code>null</code> member).
      </p>
      <table border="1" cellpadding="4" cellspacing="0">
        <tr>
          <th>supplied STXPath type</th>
          <th>target type <code>java.lang.Object</code></th>
        </tr>
        <tr>
          <td>empty sequence</td>
          <td><code>null</code></td>
        </tr>
        <tr>
          <td><code>boolean</code></td>
          <td><code>java.lang.Boolean</code> containing the boolean value</td>
        </tr>
        <tr>
          <td><code>number</code></td>
          <td><code>java.lang.Double</code> containing the number</td>
        </tr>
        <tr>
          <td><code>string</code></td>
          <td><code>java.lang.String</code></td>
        </tr>
        <tr>
          <td><code>node</code></td>
          <td><code>java.lang.String</code> containing the node value</td>
        </tr>
        <tr>
          <td>wrapped Java Object</td>
          <td>the object itself</td>
        </tr>
      </table>
              
                
      <p>
        The result of a function call will be converted as follows:
      </p>
      <table border="1" cellpadding="4" cellspacing="0">
        <tr>
          <th>return type</th>
          <th>STXPath type / value</th>
        </tr>
        <tr>
          <td><code>void</code></td>
          <td>empty sequence</td>
        </tr>
        <tr>
          <td><code>java.lang.String</code>, <code>char</code></td>
          <td><code>string</code></td>
        </tr>
        <tr>
          <td><code>boolean</code></td>
          <td><code>boolean</code></td>
        </tr>
        <tr>
          <td><code>double</code>, <code>float</code>, <code>byte</code>,
              <code>short</code>, <code>int</code>, <code>long</code></td>
          <td><code>number</code></td>
        </tr>
        <tr>
          <td>anything else, i.e. any reference type, including the value
              <code>null</code></td>
          <td>wrapped Java Object</td>
        </tr>
      </table>
      <p>
        A wrapped Java Object may be converted to another data type as
        follows.
      </p>
      <table border="1" cellpadding="4" cellspacing="0">
        <tr>
          <th>required type</th>
          <th>conversion rule</th>
        </tr>
        <tr>
          <td><code>node</code></td>
          <td>not possible</td>
        </tr>
        <tr>
          <td><code>string</code></td>
          <td><code>null</code> will be converted to the empty string,
              any other object will be converted by invoking its
              <code>toString()</code> method</td>
        </tr>
        <tr>
          <td><code>boolean</code></td>
          <td><code>null</code> will be converted to <code>false</code>,
              any other object will be converted via a
              <code>string</code> conversion and then applying the
              STXPath function <code>boolean()</code></td>
        </tr>
        <tr>
          <td><code>number</code></td>
          <td>via a <code>string</code> conversion and then applying the
              STXPath function <code>number()</code></td>
        </tr>
      </table>

      <p>
        A wrapped Java Object of type <code>java.lang.Object[]</code> or
        <code>java.util.List</code> may be converted to a sequence using
        the <em>Joost</em> extension function <code>sequence</code>.
        If the supplied parameter is neither an array nor a
        <code>java.util.List</code> object, this function returns its
        parameter.
      </p>

      <p><strong>Using external SAX2 filters</strong><br>
        <em>Joost</em> implements the usage of external SAX2 filters as
        described in the WD of the STX specification section 4.19
        (CVS version Jul 23 2003). 
        <em>Joost</em> uses the TrAX API to instantiate an XSLT transformer
        object. The actual XSLT implementation (i.e. the
        <code>javax.xml.transform.TransformerFactory</code>) to be used may
        be controlled by setting the property
        <code>net.sf.joost.trax.TrAXConstants.KEY_XSLT_FACTORY</code>, either
        as a system property or using
        <code>TransformerFactory.setAttribute</code>.
      </p>
      <p>
        Besides the XSLT (<code>http://www.w3.org/1999/XSL/Transform</code>)
        and STX (<code>http://stx.sourceforge.net/2002/ns</code>) filter
        methods, <em>Joost</em> provides built-in implementations for the
        following two additional values of the <code>filter-method</code>
        attribute:
      </p>
      <dl>
        <dt><strong><code>http://xml.org/sax</code></strong></dt>
        <dd>Provides a SAX parser. All character data will be fed into the
        parser, all other events will be ignored. The events generated by the
        parser constitute the result of this filter.</dd>
        <dt><strong><code>http://www.ietf.org/rfc/rfc2616.txt#POST</code></strong></dt>
        <dd>Sends the filter input data per HTTP-POST request to the URL
        specified in the required <code>target</code> parameter
        (i.e. <code>&lt;stx:param name="target" ... &gt;</code>). The data of
        the HTTP response are the result of this filter. The HTTP-POST filter
        can be used to access web services from STX.</dd>
      </dl>
      <p>
        A custom filter implementation must support the
        <code>javax.xml.transform.sax.TransformerHandler</code> interface.
        Such a filter can be invoked by implementing a
        <code>net.sf.joost.TransformerHandlerResolver</code> object which
        returns the filter object for a requested filter URI. This resolver
        must be registered using the property
        <code>net.sf.joost.trax.TrAXConstants.KEY_TH_RESOLVER</code>
        in the <code>TransformerFactory.setAttribute</code> method, or
        by invoking <code>setTransformerHandlerResolver</code> on a
        <code>net.sf.joost.stx.Processor</code> object. There is an example
        implementation of a filter and an appropriate resolver in the
        <code>src/samples</code> directory
        (shipped with the source release only).
      </p>
              
        
      <h4>Examples</h4>
      <p>
        The current release contains an <code>example</code> directory with a
        set of selected STX examples. In addition you may browse
        <em>Joost</em>'s CVS <a target="_top"
        href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/joost/test/">test</a>
        directory as well as the <a target="_top"
        href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/stx/stx/examples/">examples</a> directory from the STX CVS tree.
      </p>
      <h4>Resources</h4>
      <ul>
        <li>This release implements (partly) the <a href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/*checkout*/stx/specs/spec-stx.html?rev=1.48">Editor's copy of the STX Working Draft, 9 December 2003</a></li>
        <li>The functions taken from the W3C spec are defined in
         <a href="http://www.w3.org/TR/2003/WD-xpath-functions-20031112/">XQuery 1.0 and XPath 2.0 Functions and Operators, W3C Working Draft 12 November 2003</a></li>
      </ul>
      <ul>
        <li><a href="http://www.xml.com/pub/a/2003/02/26/stx.html">An
            Introduction to Streaming Transformations for XML</a>,
            Article on <a href="http://xml.com/">xml.com</a>,
            26 February 2003</li>
        <li><a href="http://www.idealliance.org/papers/dx_xmle03/papers/04-02-02/04-02-02.html">Transforming XML on the Fly</a>, Presentation at
            XML Europe 2003, London, 5-8 May 2003</li>
        <li><a href="http://www.informatik.hu-berlin.de/~obecker/Docs/EML2003/">Extended SAX Filter Processing with STX</a>, Presentation at Extreme
            Markup Languages, Montr&eacute;al, 4-8 August 2003</li>
      </ul>
      <p>
        <a target="_top" href="http://sourceforge.net">
        <img src="http://sourceforge.net/sflogo.php?group_id=55258&amp;type=5"
             width="210" height="62" border="0" alt="SourceForge Logo"
             align="right" style="margin-bottom: 5pt;"></a>
        <strong>Have fun and tell me what you think!</strong>
        <br><br>
        <span style="font-size: small">
          <a target="_top"
             href="http://www.informatik.hu-berlin.de/~obecker/">ob</a> / @@@DATE@@@
        </span>
      </p>
   </body>
</html>
