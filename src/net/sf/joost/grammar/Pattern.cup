/*
 * $Id: Pattern.cup,v 1.8 2003/04/30 15:06:03 obecker Exp $
 * 
 * The contents of this file are subject to the Mozilla Public License 
 * Version 1.1 (the "License"); you may not use this file except in 
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the 
 * License.
 *
 * The Original Code is: this file
 *
 * The Initial Developer of the Original Code is Oliver Becker.
 *
 * Portions created by  ______________________ 
 * are Copyright (C) ______ _______________________. 
 * All Rights Reserved.
 *
 * Contributor(s): ______________________________________. 
 */

package net.sf.joost.grammar;

parser code {: 
   protected java.util.Hashtable j_nsSet;
   protected org.xml.sax.Locator j_locator;
   protected net.sf.joost.instruction.TransformFactory.Instance j_transform;

   public net.sf.joost.grammar.cup.Symbol errorToken = null;

   public PatternParser(net.sf.joost.grammar.cup.Scanner s, 
                        java.util.Hashtable nsSet,
                        net.sf.joost.instruction.TransformFactory.Instance t,
                        org.xml.sax.Locator locator)
   {
      super(s);
      j_nsSet = nsSet; 
      j_transform = t;
      j_locator = locator;
   }

   private String errMsg = "";
   public void report_error(String msg, Object info)
   {
      errMsg += msg + ". ";
      errorToken = cur_token;
   }

   public void report_fatal_error(String msg, Object info)
      throws Exception
   {
      report_error(msg, info);
      done_parsing();
      throw new Exception(errMsg);
   }
:};


/* Shared terminals (with Expr.cup) */
#include "terminals.inc"

/* Non-Terminals */
non terminal Tree Pattern, MatchPath, RelativePath,
                  Step, NodeTest, NameTest, Predicate;


/* Shared expression grammar (with Expr.cup) */
#include "expr.inc"


/* Additional pattern grammar */

Pattern ::=
   MatchPath:t
      {: RESULT = t; :}
 | Pattern:t BAR MatchPath:p
      {: RESULT = new Tree(Tree.UNION, t, p); :}
 ;

MatchPath ::= 
   SLASH 
      {: RESULT = new Tree(Tree.ROOT, null); :}
 | SLASH RelativePath:t
      {: // need to add an additional leaf for root
         Tree tmp = t, last = null;
         // go down the tree to the left
         while (tmp.type == Tree.CHILD || tmp.type == Tree.DESC) {
            last = tmp;
            tmp = tmp.left;
         }
         // create a new CHILD node
         tmp = new Tree(Tree.CHILD, new Tree(Tree.ROOT, null), tmp);
         if (last == null)
            RESULT = tmp;     // return new node
         else {
            last.left = tmp;  // insert new node
            RESULT = t;       // return original
         }
      :}
 | RelativePath:t
      {: RESULT = t; :}
 ;

RelativePath ::= 
   Step:t
      {: RESULT = t; :}
 | RelativePath:p SLASH Step:s
      {: RESULT = new Tree(Tree.CHILD, p, s); :}
 | RelativePath:p DSLASH Step:s
      {: RESULT = new Tree(Tree.DESC, p, s); :}
 ;

Step ::= 
   NodeTest:n Predicate:p
      {: RESULT = (p != null) ? new Tree(Tree.PREDICATE, n, p)
                              : n; :}
 ;

Predicate ::= 
 | LBRACK Expr:t RBRACK
      {: RESULT = t; :}
 ;

NodeTest ::=
   NameTest:t
      {: RESULT = t; :}
 | KindTest:t
      {: RESULT = t; :}
 ; 

NameTest ::=
   NodeNameTest:t
      {: RESULT = t; :}
 | AttributeNameTest:t
      {: RESULT = t; :}
 ;
