/*
 * $Id: Pattern.cup,v 1.3 2002/10/29 19:09:08 obecker Exp $
 * 
 * The contents of this file are subject to the Mozilla Public License 
 * Version 1.1 (the "License"); you may not use this file except in 
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the 
 * License.
 *
 * The Original Code is: this file
 *
 * The Initial Developer of the Original Code is Oliver Becker.
 *
 * Portions created by  ______________________ 
 * are Copyright (C) ______ _______________________. 
 * All Rights Reserved.
 *
 * Contributor(s): ______________________________________. 
 */

package net.sf.joost.grammar;

parser code {: 
   protected java.util.Hashtable j_nsSet;
   protected org.xml.sax.Locator j_locator;


   public PatternParser(net.sf.joost.grammar.cup.Scanner s, 
                        java.util.Hashtable nsSet,
                        org.xml.sax.Locator locator)
   {
      super(s);
      j_nsSet = nsSet; 
      j_locator = locator;
   }

   private String errMsg = "";
   public void report_error(String msg, Object info)
   {
      errMsg += msg + ". ";
   }

   public void report_fatal_error(String msg, Object info)
      throws Exception
   {
      report_error(msg, info);
      done_parsing();
      throw new Exception(errMsg);
   }
:};

#include "terminals.inc"

/* Non-Terminals */
non terminal MatchPattern, MatchPath, RelativePath;
non terminal Step, NodeTest, NameTest, NodeNameTest, AttributeNameTest;
non terminal KindTest, Predicate, Expr, AndExpr, GeneralComp;
non terminal AdditiveExpr, MultiplicativeExpr, UnaryExpr, BasicExpr;
non terminal NodeExpr, ParentPath, FunctionCall, ExprList, Name;


/* Grammar */

MatchPattern ::=
   MatchPath:t
      {: RESULT = t; :}
 | MatchPattern:t BAR MatchPath:p
      {: RESULT = new Tree(Tree.UNION, (Tree)t, (Tree)p); :}
 ;

MatchPath ::= 
   SLASH 
      {: RESULT = new Tree(Tree.ROOT, null); :}
 | SLASH RelativePath:t
      {: // need to add an additional leaf for root
         Tree tmp = (Tree)t, last = null;
         // go down the tree to the left
         while (tmp.type == Tree.CHILD || tmp.type == Tree.DESC) {
            last = tmp;
            tmp = tmp.left;
         }
         // create a new CHILD node
         tmp = new Tree(Tree.CHILD, new Tree(Tree.ROOT, null), tmp);
         if (last == null)
            RESULT = tmp;     // return new node
         else {
            last.left = tmp;  // insert new node
            RESULT = t;       // return original
         }
      :}
 | RelativePath:t
      {: RESULT = t; :}
 ;

RelativePath ::= 
   Step:t
      {: RESULT = t; :}
 | RelativePath:p SLASH Step:s
      {: RESULT = new Tree(Tree.CHILD, (Tree)p, (Tree)s); :}
 | RelativePath:p DSLASH Step:s
      {: RESULT = new Tree(Tree.DESC, (Tree)p, (Tree)s); :}
 ;

Step ::= 
   NodeTest:n Predicate:p
      {: RESULT = (p != null) ? new Tree(Tree.PREDICATE, (Tree)n, (Tree)p)
                              : n; :}
 ;

Predicate ::= 
 | LBRACK Expr:t RBRACK
      {: RESULT = t; :}
 ;

NodeTest ::=
   NameTest:t
      {: RESULT = t; :}
 | KindTest:t
      {: RESULT = t; :}
 ; 

NameTest ::=
   NodeNameTest:t
      {: RESULT = t; :}
 | AttributeNameTest:t
      {: RESULT = t; :}
 ;

NodeNameTest ::=
   Name:n
      {: RESULT = new Tree(Tree.NAME_TEST, (String)n, 
                           parser.j_nsSet, parser.j_locator); :}
 | STAR
      {: RESULT = new Tree(Tree.WILDCARD, null); :}
 | STAR COLON NCNAME:n
      {: RESULT = new Tree(Tree.URI_WILDCARD, "*", (String)n, 
                           parser.j_nsSet, parser.j_locator); :}
 | NCNAME:n COLON STAR
      {: RESULT = new Tree(Tree.LOCAL_WILDCARD, (String)n, "*", 
                           parser.j_nsSet, parser.j_locator); :}
 ;

AttributeNameTest ::=
   AT Name:n
      {: RESULT = new Tree(Tree.ATTR, (String)n,
                           parser.j_nsSet, parser.j_locator); :}
 | AT STAR
      {: RESULT = new Tree(Tree.ATTR_WILDCARD, null); :}
 | AT STAR COLON NCNAME:n
      {: RESULT = new Tree(Tree.ATTR_URI_WILDCARD, "*", (String)n,
                           parser.j_nsSet, parser.j_locator); :}
 | AT NCNAME:n COLON STAR
      {: RESULT = new Tree(Tree.ATTR_LOCAL_WILDCARD, (String)n, "*",
                           parser.j_nsSet, parser.j_locator); :}
 ;

KindTest ::=
   COMMENT
      {: RESULT = new Tree(Tree.COMMENT_TEST, null); :}
 | NODE
      {: RESULT = new Tree(Tree.NODE_TEST, null); :}
 | PI_START RPAR
      {: RESULT = new Tree(Tree.PI_TEST, ""); :}
 | PI_START STRING:s RPAR
      {: RESULT = new Tree(Tree.PI_TEST, s); :}
 | TEXT
      {: RESULT = new Tree(Tree.TEXT_TEST, null); :}
 | CDATA
      {: RESULT = new Tree(Tree.CDATA_TEST, null); :}
 ;

#include "expr.inc"
